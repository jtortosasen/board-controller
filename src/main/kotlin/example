using System;
using System.Collections.Generic;
using System.Configuration;
using System.Diagnostics;
using System.IO;
using System.IO.Ports;
using System.Linq;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using ThreadState = System.Threading.ThreadState;

namespace ControladoraPlaca
{
    internal class Program
    {
        private const int LedRed = 1;
        private const int LedGreen = 2;
        private const int LedBlue = 3;
        private const int LedLightBlue = 4;
        private int _ledCurrent;

        private int _numTicksCounter;
        private int _numTicksCounterMaster;

        private bool _counterFinished;
        private bool _masterProtocolStarted;
        private TcpClient _tcpClient;
        private NetworkStream _networkStream;
        private readonly byte[] _bytesNack = {0x15};
        private Thread _threadTcpClient;
        private Thread _threadCounter;
        private Thread _threadCounterMaster;
        private Thread _threadSerialPort;
        private byte[] _encapsulatedLongitud;
        private int _masterProtocol;
        private bool _masterReadSuccess;

        private bool _threadClientFlag;
        private bool _threadContadorFlag;
        private bool _threadContadorPropioFlag;
        private bool _threadSerialFlag;

        private SerialPort _serialPort;

        private const int MaxMilsWaitSerialPort = 50;

        private bool _9BitMode;
        private int _serialResponseMasterMode;
        private int _sasTries;

        private const string SerialTty = @"/dev/ttyAMA4";
        // private string serialTty = @"/dev/ttyS0";

        private string _serverIp;
        private int _serverPort;

        private string _currentParity = "-parodd";

        private readonly string[,] _parityTable =
        {
            {"parodd", "-parodd"}, {"-parodd", "parodd"}, {"-parodd", "parodd"}, {"parodd", "-parodd"},
            {"-parodd", "parodd"}, {"parodd", "-parodd"}, {"parodd", "-parodd"}, {"-parodd", "parodd"},
            {"-parodd", "parodd"}, {"parodd", "-parodd"}, {"parodd", "-parodd"}, {"-parodd", "parodd"},
            {"parodd", "-parodd"}, {"-parodd", "parodd"}, {"-parodd", "parodd"}, {"parodd", "-parodd"},
            {"-parodd", "parodd"}, {"parodd", "-parodd"}, {"parodd", "-parodd"}, {"-parodd", "parodd"},
            {"parodd", "-parodd"}, {"-parodd", "parodd"}, {"-parodd", "parodd"}, {"parodd", "-parodd"},
            {"parodd", "-parodd"}, {"-parodd", "parodd"}, {"-parodd", "parodd"}, {"parodd", "-parodd"},
            {"-parodd", "parodd"}, {"parodd", "-parodd"}, {"parodd", "-parodd"}, {"-parodd", "parodd"},
            {"-parodd", "parodd"}, {"parodd", "-parodd"}, {"parodd", "-parodd"}, {"-parodd", "parodd"},
            {"parodd", "-parodd"}, {"-parodd", "parodd"}, {"-parodd", "parodd"}, {"parodd", "-parodd"},
            {"parodd", "-parodd"}, {"-parodd", "parodd"}, {"-parodd", "parodd"}, {"parodd", "-parodd"},
            {"-parodd", "parodd"}, {"parodd", "-parodd"}, {"parodd", "-parodd"}, {"-parodd", "parodd"},
            {"parodd", "-parodd"}, {"-parodd", "parodd"}, {"-parodd", "parodd"}, {"parodd", "-parodd"},
            {"-parodd", "parodd"}, {"parodd", "-parodd"}, {"parodd", "-parodd"}, {"-parodd", "parodd"},
            {"-parodd", "parodd"}, {"parodd", "-parodd"}, {"parodd", "-parodd"}, {"-parodd", "parodd"},
            {"parodd", "-parodd"}, {"-parodd", "parodd"}, {"-parodd", "parodd"}, {"parodd", "-parodd"},
            {"-parodd", "parodd"}, {"parodd", "-parodd"}, {"parodd", "-parodd"}, {"-parodd", "parodd"},
            {"parodd", "-parodd"}, {"-parodd", "parodd"}, {"-parodd", "parodd"}, {"parodd", "-parodd"},
            {"parodd", "-parodd"}, {"-parodd", "parodd"}, {"-parodd", "parodd"}, {"parodd", "-parodd"},
            {"-parodd", "parodd"}, {"parodd", "-parodd"}, {"parodd", "-parodd"}, {"-parodd", "parodd"},
            {"parodd", "-parodd"}, {"-parodd", "parodd"}, {"-parodd", "parodd"}, {"parodd", "-parodd"},
            {"-parodd", "parodd"}, {"parodd", "-parodd"}, {"parodd", "-parodd"}, {"-parodd", "parodd"},
            {"-parodd", "parodd"}, {"parodd", "-parodd"}, {"parodd", "-parodd"}, {"-parodd", "parodd"},
            {"parodd", "-parodd"}, {"-parodd", "parodd"}, {"-parodd", "parodd"}, {"parodd", "-parodd"},
            {"parodd", "-parodd"}, {"-parodd", "parodd"}, {"-parodd", "parodd"}, {"parodd", "-parodd"},
            {"-parodd", "parodd"}, {"parodd", "-parodd"}, {"parodd", "-parodd"}, {"-parodd", "parodd"},
            {"-parodd", "parodd"}, {"parodd", "-parodd"}, {"parodd", "-parodd"}, {"-parodd", "parodd"},
            {"parodd", "-parodd"}, {"-parodd", "parodd"}, {"-parodd", "parodd"}, {"parodd", "-parodd"},
            {"-parodd", "parodd"}, {"parodd", "-parodd"}, {"parodd", "-parodd"}, {"-parodd", "parodd"},
            {"parodd", "-parodd"}, {"-parodd", "parodd"}, {"-parodd", "parodd"}, {"parodd", "-parodd"},
            {"parodd", "-parodd"}, {"-parodd", "parodd"}, {"-parodd", "parodd"}, {"parodd", "-parodd"},
            {"-parodd", "parodd"}, {"parodd", "-parodd"}, {"parodd", "-parodd"}, {"-parodd", "parodd"},
            {"-parodd", "parodd"}, {"parodd", "-parodd"}, {"parodd", "-parodd"}, {"-parodd", "parodd"},
            {"parodd", "-parodd"}, {"-parodd", "parodd"}, {"-parodd", "parodd"}, {"parodd", "-parodd"},
            {"parodd", "-parodd"}, {"-parodd", "parodd"}, {"-parodd", "parodd"}, {"parodd", "-parodd"},
            {"-parodd", "parodd"}, {"parodd", "-parodd"}, {"parodd", "-parodd"}, {"-parodd", "parodd"},
            {"parodd", "-parodd"}, {"-parodd", "parodd"}, {"-parodd", "parodd"}, {"parodd", "-parodd"},
            {"-parodd", "parodd"}, {"parodd", "-parodd"}, {"parodd", "-parodd"}, {"-parodd", "parodd"},
            {"-parodd", "parodd"}, {"parodd", "-parodd"}, {"parodd", "-parodd"}, {"-parodd", "parodd"},
            {"parodd", "-parodd"}, {"-parodd", "parodd"}, {"-parodd", "parodd"}, {"parodd", "-parodd"},
            {"parodd", "-parodd"}, {"-parodd", "parodd"}, {"-parodd", "parodd"}, {"parodd", "-parodd"},
            {"-parodd", "parodd"}, {"parodd", "-parodd"}, {"parodd", "-parodd"}, {"-parodd", "parodd"},
            {"-parodd", "parodd"}, {"parodd", "-parodd"}, {"parodd", "-parodd"}, {"-parodd", "parodd"},
            {"parodd", "-parodd"}, {"-parodd", "parodd"}, {"-parodd", "parodd"}, {"parodd", "-parodd"},
            {"-parodd", "parodd"}, {"parodd", "-parodd"}, {"parodd", "-parodd"}, {"-parodd", "parodd"},
            {"parodd", "-parodd"}, {"-parodd", "parodd"}, {"-parodd", "parodd"}, {"parodd", "-parodd"},
            {"parodd", "-parodd"}, {"-parodd", "parodd"}, {"-parodd", "parodd"}, {"parodd", "-parodd"},
            {"-parodd", "parodd"}, {"parodd", "-parodd"}, {"parodd", "-parodd"}, {"-parodd", "parodd"},
            {"parodd", "-parodd"}, {"-parodd", "parodd"}, {"-parodd", "parodd"}, {"parodd", "-parodd"},
            {"-parodd", "parodd"}, {"parodd", "-parodd"}, {"parodd", "-parodd"}, {"-parodd", "parodd"},
            {"-parodd", "parodd"}, {"parodd", "-parodd"}, {"parodd", "-parodd"}, {"-parodd", "parodd"},
            {"parodd", "-parodd"}, {"-parodd", "parodd"}, {"-parodd", "parodd"}, {"parodd", "-parodd"},
            {"-parodd", "parodd"}, {"parodd", "-parodd"}, {"parodd", "-parodd"}, {"-parodd", "parodd"},
            {"parodd", "-parodd"}, {"-parodd", "parodd"}, {"-parodd", "parodd"}, {"parodd", "-parodd"},
            {"parodd", "-parodd"}, {"-parodd", "parodd"}, {"-parodd", "parodd"}, {"parodd", "-parodd"},
            {"-parodd", "parodd"}, {"parodd", "-parodd"}, {"parodd", "-parodd"}, {"-parodd", "parodd"},
            {"-parodd", "parodd"}, {"parodd", "-parodd"}, {"parodd", "-parodd"}, {"-parodd", "parodd"},
            {"parodd", "-parodd"}, {"-parodd", "parodd"}, {"-parodd", "parodd"}, {"parodd", "-parodd"},
            {"parodd", "-parodd"}, {"-parodd", "parodd"}, {"-parodd", "parodd"}, {"parodd", "-parodd"},
            {"-parodd", "parodd"}, {"parodd", "-parodd"}, {"parodd", "-parodd"}, {"-parodd", "parodd"},
            {"parodd", "-parodd"}, {"-parodd", "parodd"}, {"-parodd", "parodd"}, {"parodd", "-parodd"},
            {"-parodd", "parodd"}, {"parodd", "-parodd"}, {"parodd", "-parodd"}, {"-parodd", "parodd"},
            {"-parodd", "parodd"}, {"parodd", "-parodd"}, {"parodd", "-parodd"}, {"-parodd", "parodd"},
            {"parodd", "-parodd"}, {"-parodd", "parodd"}, {"-parodd", "parodd"}, {"parodd", "-parodd"}
        };

        public static void Main()
        {
            var program = new Program();
            program.Start();
        }

        private void Start()
        {
           ExecBashCommand("bash", "-c 'echo 30 > /sys/class/gpio/export'");
           ExecBashCommand("bash", "-c 'echo 38 > /sys/class/gpio/export'");
           ExecBashCommand("bash", "-c 'echo 40 > /sys/class/gpio/export'");
           ExecBashCommand("bash", "-c 'echo out > /sys/class/gpio/gpio30/direction'");
           ExecBashCommand("bash", "-c 'echo out > /sys/class/gpio/gpio38/direction'");
           ExecBashCommand("bash", "-c 'echo out  > /sys/class/gpio/gpio40/direction'");

            LoadConfiguration();
            Thread.Sleep(2000);

            while (true)
            {
                _counterFinished = false;

                Console.WriteLine("Iniciando cliente TCP/IP...");

                _threadTcpClient = new Thread(ThreadTcpClient);
                _threadCounter = new Thread(thContador_Conexion_Proc);
                _threadCounterMaster = new Thread(thContadorPropio_Proc);
                _threadSerialPort = new Thread(ThreadLecturaPuertoSerie);

                _threadClientFlag = true;
                _threadContadorFlag = true;
                _threadSerialFlag = true;
                _threadContadorPropioFlag = true;

                _threadTcpClient.Start();

                _threadCounter.Start();
                _threadCounter.Join();

                Console.WriteLine("Alcanzado Join de thread thContador");

                if (!_counterFinished) continue;

                if (_threadCounter.IsAlive)
                {
                    _threadContadorFlag = false;
                    _threadCounter.Join();
                    _threadCounter = null;
                }

                Console.WriteLine("thContador matado");

                if (_threadCounterMaster.IsAlive)
                {
                    _threadContadorPropioFlag = false;
                    _masterProtocolStarted = false;
                    _threadCounterMaster.Join();
                    _threadCounterMaster = null;
                }

                Console.WriteLine("thContadorPropio matado");

                if (_threadTcpClient.IsAlive)
                {
                    _threadClientFlag = false;
                    _threadTcpClient.Join();
                    _threadTcpClient = null;
                }

                Console.WriteLine("thTCPClient matado");

                if (_threadSerialPort.IsAlive)
                {
                    _threadSerialFlag = false;
                    _threadSerialPort.Join();
                    _threadSerialPort = null;
                }

                Console.WriteLine("thLecturaPuertoSerie matado");
            }
        }

        private void LoadConfiguration()
        {
            _serverIp = ConfigurationSettings.AppSettings["DireccionIpServidor"];
            _serverPort = int.Parse(ConfigurationSettings.AppSettings["PuertoServidor"]);
            Console.WriteLine("Leida configuracion. strIpServidor:" + _serverIp + ", Puerto:" + _serverPort);
        }

        private void ThreadTcpClient()
        {
            while (_threadClientFlag)
            {
                TcpClient();
                Thread.Sleep(10000);
            }
        }

        private void TcpClient()
        {
            try
            {
                _tcpClient = new TcpClient {Client = {Ttl = 8}};
                Console.WriteLine("Connecting...");
                if (!_tcpClient.ConnectAsync(_serverIp, _serverPort).Wait(500))
                {
                    Console.WriteLine("No se pudo conectar");

                    if (_ledCurrent == LedLightBlue || _ledCurrent == LedGreen)
                        TurnOnLed(LedRed);
                    return;
                }

                if (_ledCurrent != LedLightBlue)
                    TurnOnLed(LedLightBlue);

                _networkStream = _tcpClient.GetStream();
                var macAddress = MacAddress();
                _networkStream.Write(Encoding.ASCII.GetBytes("Gestimaq\r\n"), 0 , Encoding.ASCII.GetBytes("Gestimaq\r\n").Length);
                Thread.Sleep(2000);
                var bPlacaIdentificada = SendMacAddress(_networkStream, macAddress);
                if (!bPlacaIdentificada)
                {
                    Console.WriteLine("Placa NO identificada");
                    if (_tcpClient.Connected)
                        _tcpClient.Close();
                    return;
                }

                Console.WriteLine("Placa Identificada.");

                while (!_counterFinished)
                {
                    if (_ledCurrent != LedLightBlue)
                        TurnOnLed(LedLightBlue);

                    _encapsulatedLongitud = new byte[200];
                    if (!_networkStream.DataAvailable)
                    {
                        Thread.Sleep(1000);
                        continue;
                    }

                    if (_ledCurrent != LedLightBlue)
                        TurnOnLed(LedLightBlue);

                    Console.WriteLine("Esperando comando...");
                    var k2 = _networkStream.Read(_encapsulatedLongitud, 0, _encapsulatedLongitud.Length);
                    Console.WriteLine("Bytes leidos:" + k2);
                    _networkStream.Flush();

                    var iNumComandoRecibido = ParseCommand(_encapsulatedLongitud);
                    Console.WriteLine("Comando recibido: " + iNumComandoRecibido);

                    switch (iNumComandoRecibido)
                    {
                        case 22:
                            Command22();
                            break;
                        case 23:
                            Command23();
                            break;
                        case 24:
                            Command24();
                            break;
                        case 25:
                            Command25();
                            break;
                        case 40:
                            Command40();
                            break;
                        case 45:
                            Command45();
                            break;
                        case 93:
                            Command93();
                            break;
                    }
                }
                if (_tcpClient.Connected)
                    _tcpClient.Close();
            }
            catch (Exception e)
            {
                if (_ledCurrent != LedRed)
                    TurnOnLed(LedRed);
                Console.WriteLine("Error..... " + e.Message + " at " + e.StackTrace);
            }
        }

        private void ThreadLecturaPuertoSerie()
        {
            var iTotalBytesToRead = 0;
            var bCompletandoseBuffer = false;
            var lstBufferFinal = new List<byte>();
            var start = DateTime.UtcNow;

            while (_threadSerialFlag)
                try
                {
                    if (_serialPort == null) continue;
                    if (!_serialPort.IsOpen) continue;

                    var iBytesToRead = _serialPort.BytesToRead;
                    if (iBytesToRead > 0)
                    {
                        if (_ledCurrent == LedLightBlue)
                            TurnOnLed(LedGreen);
                        var buffer = new byte[iBytesToRead];
                        if (_serialPort.Read(buffer, 0, buffer.Length) <= 0) continue;
                        start = DateTime.UtcNow;

                        lstBufferFinal.AddRange(buffer);

                        bCompletandoseBuffer = true;
                        iTotalBytesToRead = iTotalBytesToRead + iBytesToRead;
                    }
                    else
                    {
                        if (!bCompletandoseBuffer) continue;
                        var end = DateTime.UtcNow;
                        var timeDiff = end - start;
                        long elapsedMs = Convert.ToInt32(timeDiff.TotalMilliseconds);

                        if (elapsedMs < MaxMilsWaitSerialPort || lstBufferFinal.Count <= 0) continue;

                        Console.WriteLine("Recibido de máquina: " +
                                          BitConverter.ToString(lstBufferFinal.ToArray()));
                        if (!_masterProtocolStarted)
                        {
                            try{
                                EncapsularEnviar_Tunel(_networkStream, lstBufferFinal.ToArray());
                            }
                            catch(Exception e){
                                break;
                            }
                        }
                        else
                        {
                            switch (_masterProtocol)
                            {
                                case 93:
                                    Protocolo_SAS_Propio(lstBufferFinal.ToArray());
                                    break;
                            }
                        }
                        bCompletandoseBuffer = false;
                        iTotalBytesToRead = 0;
                        lstBufferFinal.Clear();
                    }
                }
                catch (IOException e)
                {
                    Console.WriteLine(e);
                }
                catch (TimeoutException e)
                {
                    Console.WriteLine(e);
                }
        }

        private void thContador_Conexion_Proc()
        {
            _counterFinished = false;
            Console.WriteLine("Iniciado contador ...");
            while (_threadContadorFlag)
            {
                Thread.Sleep(1000);

                if (_numTicksCounter < 60)
                {
                    if (_ledCurrent != LedRed && _ledCurrent != LedLightBlue && _numTicksCounter > 0)
                        TurnOnLed(LedLightBlue);
                    Console.Write("{0:000 segundos}\r", _numTicksCounter);
                    _numTicksCounter++;
                }
                else
                {
                    break;
                }
            }

            _counterFinished = true;
            _numTicksCounter = 0;
        }

        private void thContadorPropio_Proc()
        {
            _threadContadorPropioFlag = true;
        bTh:
            Console.WriteLine("Iniciado contador Propio... **************");
            while (_threadContadorPropioFlag)
            {
                Thread.Sleep(1000);

                if (_numTicksCounterMaster >= 10 && _masterProtocolStarted)
                {
                    _numTicksCounterMaster = 0;
                    _serialResponseMasterMode = 0;
                    _sasTries = 1;

                    // if (_masterReadSuccess == false)
                    // {
                    //     Enviar_Error_Protocolo();
                    // }
                    // _masterReadSuccess = false;

                    if (_masterProtocol == 93) Protocolo_SAS_Propio(new byte[0]);

                    break;
                }
                if (!_masterProtocolStarted)
                {
                    break;
                }
                Console.Write("{0:    000 PROPIO}\r", _numTicksCounterMaster);
                _numTicksCounterMaster++;
            }
            _numTicksCounterMaster = 0;
            if (_masterProtocolStarted)
                goto bTh;
        }

        private void Protocolo_SAS_Propio(byte[] bBytesMaquinaAEnviar)
        {
            var serialData = "";
            var k2 = bBytesMaquinaAEnviar.Length;

            for (var i = 0; i < k2; i++)
            {
                serialData += bBytesMaquinaAEnviar[i].ToString("X");
            }

            Console.WriteLine("Recibo de la maquina:" + serialData);

            if (((_serialResponseMasterMode == 0) && (bBytesMaquinaAEnviar.Length == 0))
                || ((_serialResponseMasterMode == 0) && (bBytesMaquinaAEnviar.Length == 1) && (bBytesMaquinaAEnviar[0].Equals(112))))
            {
                if (_sasTries < 6)
                {
                    _sasTries++;

                    byte[] x80 = { 0x80 };

                    var success = WriteSerial9Bit(_serialPort, x80);

                    Console.WriteLine(success.Equals(1)
                        ? "Datos escritos en puerto serie correctamente"
                        : "Error escribiendo n puerto serie");

                    PrintArray(x80);

                    byte[] x81 = { 0x81 };

                    success = WriteSerial9Bit(_serialPort, x81);

                    Console.WriteLine(success.Equals(1)
                        ? "Datos escritos en puerto serie correctamente"
                        : "Error escribiendo n puerto serie");

                    PrintArray(x81);

                    switch (success)
                    {
                        case -1:
                            SendNack(_networkStream);
                            Console.WriteLine("Puerto serie cerrado.");
                            break;
                        case -2:
                            SendNack(_networkStream);
                            Console.WriteLine("Excepcion en Escritura en puerto serie.");
                            break;
                        default:
                        {
                            if (success > 0)
                            {
                                SendAck(_networkStream);
                                Console.WriteLine("***********************************************");
                                Console.WriteLine(" ENVIADOS DATOS POR PUERTO SERIE PROTOCOLO SAS ");
                                Console.WriteLine("***********************************************");
                            }
                            break;
                        }
                    }
                }
            }

            if (bBytesMaquinaAEnviar.Length == 0) return;

            if (!(bBytesMaquinaAEnviar[0].Equals(1)) && !(bBytesMaquinaAEnviar[0].Equals(112)) && (bBytesMaquinaAEnviar.Length == 1) && (_serialResponseMasterMode == 0))
            {
                _serialResponseMasterMode = 1;
                WriteSerial9Bit(_serialPort, new byte[] { 0x01, 0x54 });
            }

            if (bBytesMaquinaAEnviar.Length <= 1) return;

            if ((bBytesMaquinaAEnviar[0].Equals(1)) && (bBytesMaquinaAEnviar[1].Equals(84)) && (_serialResponseMasterMode == 1))
            {
                _serialResponseMasterMode = 2;
                WriteSerial9Bit(_serialPort, new byte[] {0x01, 0x6f, 0x12, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0x00, 0x04, 0x00, 0x08, 0x00, 0x09, 0x00, 0x0b, 0x00, 0x6e, 0x00, 0x0A, 0x88 });
            }

            if ((!bBytesMaquinaAEnviar[0].Equals(1)) || (!bBytesMaquinaAEnviar[1].Equals(111)) ||
                (_serialResponseMasterMode != 2)) return;
            SendMasterSas(_networkStream, bBytesMaquinaAEnviar);
            _serialResponseMasterMode = 0;
            _masterReadSuccess = true;
        }

        private string MacAddress()
        {
            return ExecCommandBashWithOutput("bash", "-c 'cat /sys/class/net/wlan0/address'")
                .Replace("\n", "").Trim();
//            return "AA:BB:CC:40:2F:EA";
        }

        private void Command22()
        {
            if (_threadCounter.ThreadState == ThreadState.Suspended)
                _threadCounter.Resume();

            StartReadSerial(9600, 8);
        }

        private void Command23()
        {
            if (_threadCounter.ThreadState == ThreadState.Suspended)
                _threadCounter.Resume();

            Console.WriteLine("Recibido comando 23 de configuracion de puerto");
            StartReadSerial(19200, 8);
        }

        private void Command24()
        {
            if (_threadCounter.ThreadState == ThreadState.Suspended)
                _threadCounter.Resume();

            StartReadSerial(19200, 9);
        }

        private void Command25()
        {
            _serialPort = AbrirPuertoSerie(new SerialPort(SerialTty), 0, 0);

            if (_serialPort.IsOpen)
            {
                SendNack(_networkStream);
                Console.WriteLine("Cierre de puerto serie fallido.");
            }
            else
            {
                SendAck(_networkStream);
                Console.WriteLine("Puerto serie cerrado con exito.");
            }
        }

        private void Command40()
        {
            Console.WriteLine("Recibido comando 40 *********************************.");
            if (!_serialPort.IsOpen)
                Send41(_networkStream);
            else
                Send42(_networkStream);
        }

        private void Command45()
        {
            int iLongitudTotalTrama = _encapsulatedLongitud[1];
            var iLongitudDatos = iLongitudTotalTrama - 8;

            Console.WriteLine("Longitud datos: " + iLongitudDatos);
            Console.WriteLine("iLongitudTotalTrama: " + iLongitudTotalTrama);

            var bbDatosAEnviarAMaquinaPorPuertoSerie = new byte[iLongitudDatos];

            Array.Copy(_encapsulatedLongitud, 8, bbDatosAEnviarAMaquinaPorPuertoSerie, 0,
                iLongitudDatos);

            int iRetValPuertoSerie;

            if (_9BitMode)
                iRetValPuertoSerie = WriteSerial9Bit(_serialPort,
                    bbDatosAEnviarAMaquinaPorPuertoSerie);
            else
                iRetValPuertoSerie = WriteSerial(_serialPort,
                    bbDatosAEnviarAMaquinaPorPuertoSerie);

            Console.WriteLine(iRetValPuertoSerie.Equals(1)
                ? "Datos escritos en puerto serie correctamente"
                : "Error escribiendo n puerto serie");

            PrintArray(bbDatosAEnviarAMaquinaPorPuertoSerie);

            switch (iRetValPuertoSerie)
            {
                case -1:
                    SendNack(_networkStream);
                    Console.WriteLine("Puerto serie cerrado.");
                    break;
                case -2:
                    SendNack(_networkStream);
                    Console.WriteLine("Excepcion en Escritura en puerto serie.");
                    break;
                default:
                {
                    if (iRetValPuertoSerie > 0) //Luego tenemos 1 y 2
                    {
                        SendAck(_networkStream);
                        Console.WriteLine("Escritura en puerto serie exitosa.");
                    }
                    break;
                }
            }
        }

        private void Command93()
        {
            _masterProtocol = 93;

            if (_threadCounter.IsAlive)
                _threadCounter.Suspend();

            _masterProtocolStarted = true;

            _numTicksCounterMaster = 0;

            switch (_threadCounterMaster.ThreadState)
            {
                case ThreadState.Unstarted:
                    _threadCounterMaster.Start();
                    break;
                case ThreadState.Suspended:
                    _threadCounterMaster.Resume();
                    break;
                case ThreadState.AbortRequested | ThreadState.Stopped:
                    _threadCounterMaster = new Thread(thContadorPropio_Proc);
                    _threadCounterMaster.Start();
                    break;
                case ThreadState.Aborted:
                    _threadCounterMaster = new Thread(thContadorPropio_Proc);
                    _threadCounterMaster.Start();
                    break;
            }

             _serialPort = AbrirPuertoSerie(new SerialPort(SerialTty), 19200, 9);

            switch (_threadSerialPort.ThreadState)
            {
                case ThreadState.Unstarted:
                    _threadSerialPort.Start();
                    break;
                case ThreadState.Suspended:
                    _threadSerialPort.Resume();
                    break;
                case ThreadState.AbortRequested | ThreadState.Stopped:
                    _threadSerialPort = new Thread(ThreadLecturaPuertoSerie);
                    _threadSerialPort.Start();
                    break;
                case ThreadState.Aborted:
                    _threadSerialPort = new Thread(ThreadLecturaPuertoSerie);
                    _threadSerialPort.Start();
                    break;
            }

            if (_serialPort.IsOpen)
            {
                SendAck(_networkStream);
                Console.WriteLine("Apertura en puerto serie exitosa.");
            }
            else
            {
                SendNack(_networkStream);
                Console.WriteLine("Excepcion en apertura en puerto serie.");
            }
        }

        private bool SendMacAddress(Stream stream, string macAddress)
        {
            var strArrMacBytesNumSerie = macAddress.Split(':');
            var bytesMac = new byte[3];
            bytesMac[0] = Convert.ToByte(strArrMacBytesNumSerie[3], 16);
            bytesMac[1] = Convert.ToByte(strArrMacBytesNumSerie[4], 16);
            bytesMac[2] = Convert.ToByte(strArrMacBytesNumSerie[5], 16);

            byte[] bytesComandoIdentificacion11 = {0x55, 0xFF, 0x11, 0xFF, 0x11, 0x03};

            var bytesLongitud = BitConverter.GetBytes(bytesComandoIdentificacion11.Length + bytesMac.Length + 2);
            var bAnteFinal = Combine(bytesComandoIdentificacion11, bytesMac);
            var bFinal = AddByteToArray(bAnteFinal, bytesLongitud[0]);
            var bFinal2 = AddByteToArray(bFinal, bytesLongitud[1]);

            Console.WriteLine("Transmitting.....");
            Console.WriteLine(bFinal2.Length);
            stream.Write(bFinal2, 0, bFinal2.Length);

            for (var i = 0; i < 20; i++)
            {
                var array = new byte[100];

                if (stream.CanRead)
                    stream.Read(array, 0, array.Length);

                if (array[0].Equals(6))
                {
                    Console.WriteLine("Recibido <ACK>");

                    return true;
                }
                if (array[0].Equals(15))
                {
                    Console.WriteLine("WARNING !!!! Recibido <NACK>");
                    Console.WriteLine("ERROR: Placa NO Identificada.");
                    _numTicksCounter = 0;
                    return false;
                }
            }
            return false;
        }

        private void Send41(Stream stm)
        {
            byte[] phrase = {0x00, 0x08, 0x55, 0xFF, 0x41, 0xFF, 0x41, 0x03};

            try
            {
                stm.Write(phrase, 0, phrase.Length);
                Console.WriteLine("Enviada confirmación 41.");
            }
            catch (Exception e)
            {
                Console.WriteLine(e);
            }
        }

        private void Send42(Stream stm)
        {
            byte[] phrase = {0x00, 0x08, 0x55, 0xFF, 0x42, 0xFF, 0x42, 0x03};

            try
            {
                stm.Write(phrase, 0, phrase.Length);
                Console.WriteLine("Enviada confirmación 42.");
            }
            catch (Exception e)
            {
                Console.WriteLine(e);
            }
        }

        private void SendAck(Stream stm)
        {
            byte[] phrase = {0x00, 0x03, 0x06};

            try
            {
                stm.Write(phrase, 0, phrase.Length);
                Console.WriteLine("Enviada confirmación ACK.");
            }
            catch (IOException e)
            {
                Console.WriteLine(e.StackTrace);
                _tcpClient.Client.Disconnect(false);

                _numTicksCounter = 60;

                if (_threadCounter.IsAlive)
                    _threadCounter.Suspend();

                switch (_threadCounter.ThreadState)
                {
                    case ThreadState.Unstarted:
                        _threadCounter.Start();
                        break;
                    case ThreadState.Suspended:
                        _threadCounter.Resume();
                        break;
                    case ThreadState.AbortRequested | ThreadState.Stopped:
                        _threadCounter = new Thread(thContador_Conexion_Proc);
                        _threadCounter.Start();
                        break;
                }
            }
            catch (Exception e)
            {
                Console.WriteLine(e.StackTrace);
            }
        }

        private void SendNack(Stream stm)
        {
            try
            {
                var bytesLongitud2 = BitConverter.GetBytes(_bytesNack.Length + 2);

                var bFinal3 = AddByteToArray(_bytesNack, bytesLongitud2[0]);
                var bFinal4 = AddByteToArray(bFinal3, bytesLongitud2[1]);

                stm.Write(bFinal4, 0, bFinal4.Length);
                Console.WriteLine("Enviado NACK.");
            }
            catch (Exception ex)
            {
                Console.WriteLine("Excepcion en EnviarTramaControl_NACK:" + ex.Message);
            }
        }

        private void EncapsularEnviar_Tunel(Stream stm, byte[] bBytesMaquinaAEnviar)
        {
            byte[] bytesEncapsulado = {0x55, 0xFF, 0x45, 0xFF, 0x45, 0x03};
            try
            {
                var bytesLongitud2 = BitConverter.GetBytes(bytesEncapsulado.Length + bBytesMaquinaAEnviar.Length + 2);

                var bPrimero = Combine(bytesEncapsulado, bBytesMaquinaAEnviar);
                var bFinal3 = AddByteToArray(bPrimero, bytesLongitud2[0]);
                var bFinal4 = AddByteToArray(bFinal3, bytesLongitud2[1]);

                stm.Write(bFinal4, 0, bFinal4.Length);
            }
            catch (Exception ex)
            {
                if (_ledCurrent != LedRed)
                    TurnOnLed(LedRed);
                Console.WriteLine("Excepcion en EnviarDatosMaquina:" + ex.Message);
                throw new System.Exception();
            }
        }


        private int WriteSerial9Bit(SerialPort serialPort, IReadOnlyList<byte> bytesToWrite)
        {
            if (_ledCurrent == LedLightBlue)
                TurnOnLed(LedGreen);
            return SendWithParity9Bit(serialPort, bytesToWrite);
        }

        private int SendWithParity9Bit(SerialPort serialTty, IReadOnlyList<byte> bytesToWrite)
        {
            if (_ledCurrent == LedLightBlue)
                TurnOnLed(LedGreen);

            var iLongitud = bytesToWrite.Count;
            var iRetVal = 0;

            for (var n = 0; n < iLongitud; n++)
            {
                //Si estamos en el primer byte cogemos la primera columna de la tabla.
                //Si no estamos en el primer byte cogemos la segunda columna de la tabla.
                var newParity = n == 0 ? _parityTable[bytesToWrite[n], 0] : _parityTable[bytesToWrite[n], 1];
                Console.WriteLine("Nueva_Paridad:" + newParity);

                //Si hay un cambio de paridad desde el último envío, configuramos el puerto.
                if (newParity != _currentParity)
                {
                    serialTty = SwapParity(serialTty, newParity);
                    Thread.Sleep(10);
                    //Actualizamos paridad actual.
                    _currentParity = newParity;
                }
                //Enviamos el Byte que corresponde
                iRetVal = WriteSerial(serialTty, new[] {bytesToWrite[n]});
            }

            return iRetVal;
        }

        private SerialPort SwapParity(SerialPort serialTty, string strParidad)
        {
            var strComando = "-c 'stty -F " + serialTty.PortName + " 19200 cs8 -cstopb ignpar parenb " + strParidad +
                             "'";
            Console.WriteLine("Comando:" + strComando);
            try
            {
                ExecBashCommand("bash", strComando);
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.StackTrace);
            }

            return serialTty;
        }

        private SerialPort AbrirPuertoSerie(SerialPort Serial_tty, int iBaudRate, int iDataBits)
        {
            try
            {
                if (_ledCurrent == LedLightBlue)
                    TurnOnLed(LedGreen);

                if (!iBaudRate.Equals(0) && !iDataBits.Equals(0))
                {
                    if (!Serial_tty.IsOpen)
                    {
                        if (iDataBits.Equals(8))
                        {
                            Serial_tty.BaudRate = iBaudRate; // Baudrate = 9600bps
                            Serial_tty.Parity = Parity.None; // Parity bits = none
                            Serial_tty.DataBits = iDataBits; // No of Data bits = 8
                            Serial_tty.StopBits = StopBits.One; // No of Stop bits = 1
                            Serial_tty.ReadTimeout = 50;
                            Serial_tty.Open(); // Open the port
                            _9BitMode = false;
                        }
                        else
                        {
                            Serial_tty.BaudRate = iBaudRate; // Baudrate = 19200bps
                            Serial_tty.Parity = Parity.Even; // Parity bits = Par por ejemplo
                            Serial_tty.DataBits = 8; // No of Data bits = 8 (obligamos a 8 bits)
                            Serial_tty.StopBits = StopBits.One; // No of Stop bits = 1
                            Serial_tty.ReadTimeout = 50;
                            Serial_tty.Open();
                            _9BitMode = true;
                        }
                    }
                    else
                    {
                        if (iDataBits.Equals(8))
                        {
                            if (!Serial_tty.BaudRate.Equals(iBaudRate) || !Serial_tty.DataBits.Equals(iDataBits))
                            {
                                Serial_tty.Close(); //Cerramos
                                Serial_tty.BaudRate = iBaudRate; // Baudrate = 9600bps
                                Serial_tty.Parity = Parity.None; // Parity bits = none
                                Serial_tty.DataBits = iDataBits; // No of Data bits = 8
                                Serial_tty.StopBits = StopBits.One; // No of Stop bits = 1
                                Serial_tty.ReadTimeout = 50;
                                Serial_tty.Open(); // Open the port
                                _9BitMode = false;
                            }
                        }
                        else
                        {
                            if (!Serial_tty.BaudRate.Equals(iBaudRate) || !Serial_tty.DataBits.Equals(iDataBits))
                            {
                                // Esto es solo para 9 bits cuanddo el puerto ya esta configurado y abierto con configuración de 8 bits
                                Serial_tty = SwapParity(Serial_tty, "-parodd");
                                _9BitMode = true;
                            }
                        }
                    }
                }
                else
                {
                    if (Serial_tty.IsOpen)
                        Serial_tty.Close();
                }
            }
            catch (IOException ioex)
            {
                Serial_tty.Close();
                Console.WriteLine("Excepcion en TryOpenSerialPort: " + ioex);
            }
            return Serial_tty;
        }

        private int WriteSerial(SerialPort serialPort, byte[] bytesToWrite)
        {
            if (_ledCurrent == LedLightBlue)
                TurnOnLed(LedGreen);
            try
            {
                if (!serialPort.IsOpen) return -1;

                serialPort.Write(bytesToWrite, 0, bytesToWrite.Length);
                return 1;
            }
            catch (IOException)
            {
                return -2;
            }
        }

        private void StartReadSerial(int iBaudRate, int iDataBits)
        {
            _serialPort = AbrirPuertoSerie(new SerialPort(SerialTty), iBaudRate, iDataBits);

            switch (_threadSerialPort.ThreadState)
            {
                case ThreadState.Unstarted:
                    _threadSerialPort.Start();
                    break;
                case ThreadState.Suspended:
                    _threadSerialPort.Resume();
                    break;
                case ThreadState.AbortRequested | ThreadState.Stopped:
                    _threadSerialPort = new Thread(ThreadLecturaPuertoSerie);
                    _threadSerialPort.Start();
                    break;
                case ThreadState.Aborted:
                    _threadSerialPort = new Thread(ThreadLecturaPuertoSerie);
                    _threadSerialPort.Start();
                    break;
            }

            if (_serialPort.IsOpen)
            {
                SendAck(_networkStream);
                Console.WriteLine("Apertura en puerto serie exitosa.");
            }
            else
            {
                SendNack(_networkStream);
                Console.WriteLine("Excepcion en apertura en puerto serie.");
            }
        }

        private void TurnOffLed(int led)
        {
            try
            {
                StreamWriter streamWriter;
                switch (led)
                {
                    case LedRed:
                        streamWriter = new StreamWriter("/sys/class/gpio/gpio38/value", false);
                        streamWriter.Write(0);
                        streamWriter.Close();
                        break;
                    case LedBlue:
                        streamWriter = new StreamWriter("/sys/class/gpio/gpio30/value", false);
                        streamWriter.Write(0);
                        streamWriter.Close();
                        break;
                    case LedGreen:
                        streamWriter = new StreamWriter("/sys/class/gpio/gpio40/value", false);
                        streamWriter.Write(0);
                        streamWriter.Close();
                        break;
                    case LedLightBlue:
                        streamWriter = new StreamWriter("/sys/class/gpio/gpio30/value", false);
                        streamWriter.Write(0);
                        streamWriter.Close();
                        streamWriter = new StreamWriter("/sys/class/gpio/gpio40/value", false);
                        streamWriter.Write(0);
                        streamWriter.Close();
                        break;
                }
            }
            catch (IOException e)
            {
                Console.WriteLine(e.StackTrace);
            }
        }

        private void TurnOnLed(int led)
        {
            try
            {
                StreamWriter streamWriter;
                switch (led)
                {
                    case LedRed:
                        TurnOffLed(_ledCurrent);
                        streamWriter = new StreamWriter("/sys/class/gpio/gpio38/value", false);
                        streamWriter.Write(1);
                        streamWriter.Close();
                        _ledCurrent = led;
                        break;
                    case LedBlue:
                        TurnOffLed(_ledCurrent);
                        streamWriter = new StreamWriter("/sys/class/gpio/gpio30/value", false);
                        streamWriter.Write(1);
                        streamWriter.Close();
                        _ledCurrent = led;
                        break;
                    case LedGreen:
                        TurnOffLed(_ledCurrent);
                        streamWriter = new StreamWriter("/sys/class/gpio/gpio40/value", false);
                        streamWriter.Write(1);
                        streamWriter.Close();
                        _ledCurrent = led;
                        break;
                    case LedLightBlue:
                        TurnOffLed(_ledCurrent);
                        streamWriter = new StreamWriter("/sys/class/gpio/gpio30/value", false);
                        streamWriter.Write(1);
                        streamWriter.Close();
                        streamWriter = new StreamWriter("/sys/class/gpio/gpio40/value", false);
                        streamWriter.Write(1);
                        streamWriter.Close();
                        _ledCurrent = led;
                        break;
                }
            }
            catch (IOException e)
            {
                Console.WriteLine(e.StackTrace);
            }

            _ledCurrent = led;
        }

        private string ExecCommandBashWithOutput(string strPrograma, string strParams)
        {
            var output = string.Empty;

            var psi = new ProcessStartInfo(strPrograma, strParams)
            {
                RedirectStandardOutput = true, WindowStyle = ProcessWindowStyle.Hidden, UseShellExecute = false
            };
            var proc = Process.Start(psi);
            var myOutput = proc.StandardOutput;
            proc.WaitForExit(50000);
            if (proc.HasExited) output = myOutput.ReadToEnd();

            return output;
        }

        private void ExecBashCommand(string strPrograma, string strParams)
        {
            var psi = new ProcessStartInfo(strPrograma, strParams)
            {
                RedirectStandardOutput = true, WindowStyle = ProcessWindowStyle.Hidden, UseShellExecute = false
            };
            var proc = Process.Start(psi);
            proc.WaitForExit();
        }

        private int ParseCommand(byte[] bBytesComando)
        {
            var hexReceived = string.Empty;

            var COMANDO_22 = "55FF22FF223";
            var COMANDO_23 = "55FF23FF233";
            var COMANDO_24 = "55FF24FF243";
            var COMANDO_25 = "55FF25FF253";
            var COMANDO_40 = "55FF40FF403";
            var COMANDO_45 = "55FF45FF453";
            var COMANDO_93 = "55FF93FF933";

            var iNumComandoADevolver = 0;

            var k2 = bBytesComando.Length;

            var strPrimerByte = bBytesComando[0].ToString("X");

            if (strPrimerByte.Equals("0"))
            {
                for (var i = 2; i < k2; i++)
                {
                    hexReceived += bBytesComando[i].ToString("X");
                }

                _numTicksCounter = 0;
                iNumComandoADevolver = 45;
            }
            else
            {
                for (var i = 0; i < k2; i++)
                {
                    hexReceived += bBytesComando[i].ToString("X");
                }

                if (hexReceived.StartsWith(COMANDO_22))
                {
                    _numTicksCounter = 0;
                    iNumComandoADevolver = 22;
                }
                else if (hexReceived.StartsWith(COMANDO_23))
                {
                    _numTicksCounter = 0;
                    iNumComandoADevolver = 23;
                }
                else if (hexReceived.StartsWith(COMANDO_24))
                {
                    _numTicksCounter = 0;
                    iNumComandoADevolver = 24;
                }
                else if (hexReceived.StartsWith(COMANDO_25))
                {
                    _numTicksCounter = 0;
                    iNumComandoADevolver = 25;
                }
                else if (hexReceived.StartsWith(COMANDO_40))
                {
                    _numTicksCounter = 0;
                    iNumComandoADevolver = 40;
                }
                else if (hexReceived.StartsWith(COMANDO_93))
                {
                    _numTicksCounter = 0;
                    iNumComandoADevolver = 93;
                }
            }

            return iNumComandoADevolver;
        }

        private byte[] AddByteToArray(byte[] bArray, byte newByte)
        {
            var newArray = new byte[bArray.Length + 1];
            bArray.CopyTo(newArray, 1);
            newArray[0] = newByte;
            return newArray;
        }

        private byte[] Combine(byte[] first, byte[] second)
        {
            var ret = new byte[first.Length + second.Length];
            Buffer.BlockCopy(first, 0, ret, 0, first.Length);
            Buffer.BlockCopy(second, 0, ret, first.Length, second.Length);
            return ret;
        }

        private void PrintArray(IEnumerable<byte> array)
        {
            foreach (var t in array)
                Console.Write(t.ToString("X"));
            Console.WriteLine("");
        }

        private void Enviar_Error_Protocolo()
        {
            switch (_masterProtocol)
            {
                case 93:
                    SendMasterSas(_networkStream, new byte[] { 0x15, 0x01, 0x15 });
                    break;
            }
        }

        private void SendMasterSas(Stream stm, byte[] arrayBytes)
        {
            byte[] phrase = { 0x55, 0xE0, 0x93, 0xE0, 0x93, 0x03 };

            try
            {
                var bytesLongitud2 = BitConverter.GetBytes(phrase.Length + arrayBytes.Length + 2);

                var bPrimero = Combine(phrase, arrayBytes);
                var bFinal3 = AddByteToArray(bPrimero, bytesLongitud2[0]);
                var bFinal4 = AddByteToArray(bFinal3, bytesLongitud2[1]);

                stm.Write(bFinal4, 0, bFinal4.Length);
                var strCadenaIntHexaRecibidos = bFinal4.Aggregate(string.Empty, (current, t) => current + t.ToString("X"));
                Console.WriteLine("Encapsulado y enviado:" + strCadenaIntHexaRecibidos);
            }
            catch (Exception ex)
            {
                Console.WriteLine("Excepcion en Encapsulado y envío:" + ex.Message);
            }
        }
    }
}